Генератор парсеров
На входе грамматика, на выходе классы AST и код
Грамматика задаётся функциями, которые возвращают маленькие промежуточные структурки
Классы AST наследуются от базового класса ASTNode!(Args), где Args - граматика данного класса (промежуточные структурки)
Поля классов AST можно сгенерировать по промежуточным структуркам
Код парсинга нельзя
Чтобы сгенерировать код, нужно избавиться от ветвлений, в которых две или более веток начинаются одинаково, т. к. в таких ветвлениях непонятно будет по какой ветке идти
Из таких веток нужно выносить общие куски. Эта процедура называется transform

choice(
	Common => EndOfBranchA,
	Common => EndOfBranchB,
	BranchC
)

transforms to

choice(
	Common => choice(EndOfBranchA, EndOfBranchB),
	BranchC
)

Эту процедуру нельзя выполнить на промежуточных структурках, так как для каждой ноды нужно знать какая нода следующая. Удобнее всего использовать структуру данных список. Каждая нода хранит в себе указатель на следующую. Структуры не подходят, т. к. будут проблемы с указателями и тем фактом, что структуры копируются и выходят из scope как не в себе. Для списка нужно чтобы элементы и ссылки на них оставались валидными.
Алгоритм transform для choice:
	1. Запустить transform для следующей вершины
	2. Найти ветки с общим началом, вынести общую часть так, как написано выше, повторять пока есть ветки с общим началом
Остальные вершины просто запускают transform для следующей вершины

Все ноды делятся на три типа:
	1. Собственно парсеры (константный токен [ключевое слово, оператор и пр.] и идентификатор)
	2. Ветвления (choice и его подмножество optional)
	3. Циклы с разделителем

Сохранение напарсенного в AST: каждая нода хранит в себе информацию о том, куда сохранять результат в виде ["supernode", "node", "subnode", "field"]. Прежде чем записать результат в supernode.node.subnode.field проверяем на null supernode, supernode.node и supernode.node.subnode, при необходимости выделяем память

Ветвления - есть несколько веток, мы выбираем одну.
В КОНЦЕ ВЕТВЛЕНИЯ ВЕТКИ СХОДЯТСЯ И ЭТО ВЛИЯЕТ НА TRANSFORM!
Вынесение ноды в конце ветвления:

choice(
	Common,
	,  // empty
	BranchC
)
=>
Common

transforms to

choice(
	Common => Common,
	Common,  // empty
	BranchC => Common
)

and

choice(
	Common => choice(Common, ),
	BranchC => Common
)


Циклы:
	Если нужно вынести ноду из цикла, то разворячиваем целую итерацию

Цикл while:    loop_begin => optional(separator => contents => loop_continue) => loop_end
Цикл do-while  loop_begin => contents => optional(separator => loop_continue) => loop_end

loop_begin    - do {
loop_continue -   continue;
loop_end      - } while (0);
